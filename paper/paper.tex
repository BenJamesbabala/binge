\documentclass[sigchi]{acmart}

\usepackage{booktabs}
\usepackage{commath}
\usepackage{threeparttable}

% --- Symbols
\newcommand\symUserSet{U}
\newcommand\symItemSet{I}
\newcommand\symUserFeaturesSet{F^U}
\newcommand\symItemFeaturesSet{F^I}
\newcommand\symItemEmbeddingMatrix{E^I}
\newcommand\symUserEmbeddingMatrix{E^U}

\newcommand\symUserInteractionSet{S}

\DeclareMathOperator{\sign}{sign}
\renewcommand\vec{\mathbf}

\begin{document}

\title{Binary Latent Representations for Efficient Ranking}
\author{Maciej Kula}
\email{maciej.kula@gmail.com}
\date{\today}
\settopmatter{printacmref=false, printccs=false, printfolios=true}
\setcopyright{none}
\acmConference[]{}{}{}


\begin{abstract}
Large-scale recommender systems often face severe latency and storage constraints at prediction time. These are particularly acute when the number of items that could be recommended is large, and calculating predictions for the full set is computationally intensive. To relax these constraints, we train recommendation models that use binary rather than real-valued user and item representations, and show that they offer a range of attractive speed-accuracy trade-offs. In particular, we demonstrate 13 times faster prediction at the expense of a modest 4\% loss in ranking accuracy on the Movielens 100K dataset.
\end{abstract}

\maketitle

\section{Introduction}
Industry ranking and recommendation systems need to scale to tens or hundreds of millions of items and users. As the number of items available to be recommended grows large, efficiently ranking the item catalogue to produce top-ranked recommendations becomes increasingly challenging. With large catalogues, ranking latency (in on-line settings) and compute and storage costs (in pre-compute settings) place significant contraints on the design of the entire recommender system.

In an on-line setting, where recommendation latency directly impacts the user experience, system designers have to work within a strict latency budget. Respecting that budget often means trading off model accuracy for speed, either via smaller and less expressive models (with lower-dimensionality representations) or through aggressive use of heuristics to exclude large classes of candidate items from scoring. For example, Pinterest uses a combination of heuristics and candidate-generation models to select approximately 1000 pins, from billions of available pins, as input to its related pins ranking system \citep{liu2017related}. Similarly, approximate nearest neighbour search techniques are used at YouTube \citep{covington2016deep} to reduce the number of candidate videos that need to be scored for each user.

The challenge of low-latency scoring leads many systems to rely on a pre-compute system, where recommendations are calculated in advance and stored for serving at a later time. The primary disadvantage of such a system is its inability to react dynamically to user actions (such as new interactions that allow the recommendations to be refined) and recommendation context (location, time of day or year). This leads to often complex architectures that mix fairly simple on-line models, computationally expensive offline models, and intermediate complexity near-line algorithms where model updating is important \citep{amatriain2013big}.

Additionaly, while a pre-compute solution removes model prediction from the critical path, it still requires substantial investment in computational and storage resources to calculate and cache the predictions of the model. Often the amount of comutation required makes timely updating of the cached results impossible. At Pinterest, pre-calculation of related pins results was so demanding that ranking of different segments of the catalogue had to be staggered in time, leading to stale results and reduced ease of development \citep[Section 5.5]{liu2017related}. \citet{koenigstein2012efficient} estimate that computing recommendations for the Yahoo! Music dataset \citep{dror2011yahoo} with a 50-dimensional latent factor model woud take over 135 hours.

To alleviate these constraints in both online and offline settings, we propose the use of binary item and user representations in learning-to-rank matrix factorization models. Following the approach of \citet{rastegari2016xnor}, we show that we can estimate binary user and item representations that achieve comparable ranking accuracy to standard learning-to-rank approaches while being several times faster to score, requiring a fraction of the memory, and being only marginally more complex to estimate. In MovieLens 100k experiments, our binary representations are within 4\% of the accuracy of the real-valued model, but are over 13 times faster to score and take only 6\% of the memory.

\section{Our approach}
\label{sec:approach}
\citet{rastegari2016xnor} introduce XNOR-Networks, an approach that combines 1-bit quantization of fully-connected and convolutional layers with representing dot products through scaled XNOR and bitcounting operations.

We adapt their approach to the recommendation task by learning binary versions of user and item vectors within a learning-to-rank factorization model. This allows us to use binary instead of floating point operations for computing recommendation rankings, which has significant speed and memory use advantages. In a real-valued $n$-dimensional factorization model, item and user representations take $4n$ bytes of memory, and computing a single prediction takes $2n$ floating point operations. In an equivalent binary model, $\frac{3}{32}n$ binary operations are required for each prediction (XOR, negation, and bitcounting), and the representations take $\frac{1}{8}n$ bytes of memory. Naive calculations suggest that, for the same latent dimensionality, a binary model would be over 20 times faster to score, and take less then 5\% of memory to store its representations.

Naturally, using binary instead of real-valued representations entails a loss of representational power, and the resulting models can be expected to be less accurate. Nevertheless, binary models may still be very useful in a production system, for two reasons. Firstly, they may offer the system designer a more favourable trade-off between speed and accuracy than simply changing the number of latent dimensions in a real-valued model. If latency is the binding constraint, switching to a binary model may offer better or comparable speed with better ranking performance. If accuracy is the priority, a binary model may offer equivalent ranking performance while being faster to score. This suspicion is borne out in our experiments. Secondly, many production systems resort to heavy use of heuristics when selecting candidates to be scored by their ranking systems (as scoring all candidates would be infeasible). To the extent that these heuristics are suboptimal, replacing them with a binary representation model would improve the overall accuracy of the system.

To quantify the tradeoffs involved, we construct and fit both a real-valued and a binary version of simple implicit learning-to-rank factorization model. We introduce the notation and the models below.

Let $\symUserSet$ be the set of users, and $\symItemSet$ be the set of items. Each user interacts with a number of items $\symUserInteractionSet_i^+$; the set of all remaining items is denoted by $\symUserInteractionSet^-$.

In a traditional real-valued latent factor model, the prediction $r_{ui}$ for any user-item interaction pair $(u, i) \in \symUserSet \times \symItemSet$ is given by
\begin{equation}
r_{ui} = \vec{u}_u \cdot \vec{i}_i + b_u + b_i
\end{equation}
where $\vec{u}_u$ denotes the user and $\vec{i}_i$ the item $n$-dimensional latent vectors, and $b_u$ and $b_i$ the user and item biases.

\citet{rastegari2016xnor} show that the dot product of two real-valued vectors can be approximated in the binary domain by (1) binarizing the input vectors using the sign function (so that the results lie in $\{1, -1\}$), (2) taking their dot product, and (3) scaling the result by the average magnitude of the vectors' elements. Letting
\begin{equation}
\alpha = \frac{1}{n}\norm{\vec{i}_{i}}_{\ell1}
\end{equation}
and
\begin{equation}
\beta = \frac{1}{n}\norm{\vec{u}_{u}}_{\ell1}
\end{equation}
represent the scaling factors, the approximation is given by
\newcommand\binaryApproximation{ \alpha \beta\left(\sign(\vec{u}_u) \cdot \sign(\vec{i}_i)\right)}
\begin{equation}
\vec{u}_u \cdot \vec{i}_i \approx \binaryApproximation
\end{equation}
Applying this to the latent-factor model, the prediction for a user-item pair is given by
\begin{equation}
r_{ui} = \binaryApproximation + b_u + b_i
\end{equation}
Note that the scaling factors $\alpha$ and $\beta$ need to be stored (in addition to the latent representations and biases) to compute predictions in the binary model.

The model is trained using backpropagation, and so we use a smooth approximation to the derivative of the sign function to facilitate training. Following \citet{courbariaux2016binarized}, we define
\begin{equation}
  \frac{d\sign}{dw}=
  \begin{cases}
    w & \text{if}\ \abs{w} \leq 1 \\
    0 & \text{otherwise}.
  \end{cases}
\end{equation}

We use two loss functions to train the model:
\begin{itemize}
\item Bayesian personalised ranking (BPR, \citet{rendle2009bpr}), and
\item adaptive sampling maximum margin loss, following \citet{weston2011wsabie}.
\end{itemize}
For both loss functions, for any known positive user-item interaction pair $(u, i)$, we uniformly sample an implicit negative item $j \in \symUserInteractionSet^-$. For BPR, the loss for any such triplet is given by
\begin{equation}
1 - \sigma\left(r_{ui} - r_{uj}\right),
\end{equation}
where $\sigma$ denotes the sigmoid function.
The adaptive sampling loss is given by
\begin{equation}
\abs{1 - r_{ui} + r_{uj}}_{+}.
\end{equation}
For any $(u, i)$ pair, if the sampled negative item $j$ results in a zero loss (that is, the desired pairwise ordering is not violated), a new negative item is sampled, up to a total of $k$ attempts. This leads the model to perform more gradient updates in areas where its ranking performance is poorest.

For the purposes of this paper, we focus on a simple bilinear collaborative filtering model, and do not use any external metadata information or model the sequential nature of the data. However, the binary dot product approach generalizes beyond simple factorization models, and can be applied as a component of any model whose final scoring step involves a dot product between user and item representations. In particular, models using recurrent \citep{hidasi2015session} or convolutional \citep{lynch2015images} item or user representations can easily be augmented to use binary dot products in the final ranking stages. Assuming item representations can be computed in advance, even very complicated models can enjoy the efficiency advantages of using binary representations.

\section{Experiments}
\begin{table*}[htbp]
\begin{threeparttable}
\caption{Movielens 100K results}
\label{tb:results}
\centering
\begin{tabular}{rrrrrrrr}
\toprule
Dimension &   MRR & Binary MRR & MRR ratio\tnote{1} &   PPMS\tnote{2} & Binary PPMS & PPMS ratio & Memory use ratio \\
\midrule
       32 & 0.096 &      0.088 &     0.919 & 89,299 &     245,644 &      2.751 &            0.091 \\
       64 & 0.098 &      0.096 &     0.973 & 47,565 &     209,486 &      4.404 &            0.062 \\
      128 & 0.108 &      0.091 &     0.843 & 20,502 &     156,404 &      7.629 &            0.047 \\
      256 & 0.109 &      0.097 &     0.884 & 10,631 &     166,500 &     15.661 &            0.039 \\
      512 & 0.112 &      0.105 &     0.938 &   5391 &     110,418 &     20.479 &            0.035 \\
     1024 & 0.114 &      0.102 &     0.897 &   2689 &      69,349 &     25.786 &            0.033 \\
     2048 & 0.111 &      0.109 &     0.984 &   1352 &      34,826 &     25.745 &            0.032 \\
     4096 & 0.111 &      0.107 &     0.961 &    666 &      15,907 &     23.856 &            0.032 \\
\bottomrule
\end{tabular}
\begin{tablenotes}
\small{
\item[1] Ratio of binary model MRR to real-valued model MRR
\item[2] Predictions Per Millisecond
}
\end{tablenotes}
\end{threeparttable}
\end{table*}
To assess the accuracy-speed trade-offs enabled by the XNOR approach, we conduct an experiment on the Movielens 100K dataset \citep{harper2016movielens}. The dataset contains 100 thousand ratings from 943 users on 1682 movies. Because the computational speed improvements offered by the binary representations are linear in the size of the catalogue, the results on this dataset should be indicative of results that can be obtained on larger datasets. At the same time, the dataset's small size enables us to easily test hyperparameter configurations and estimate models with high latent dimensions.

\subsection{Experimental setup}
We randomly divide the dataset into a training, test, and validation set. In order to build a picture of the accuracy-speed trade-offs afforded by real-valued and binary latent models, we explicitly build models for between 32 and 4096 latent dimensions. For every latent dimensionality, we conduct a random search over the hyperparameter space, and pick optimal learning rates and minibatch sizes for each algorithm based on their performance on the test set. The final results are obtained from ranking interactions from the validation set. We use mean reciprocal rank (MRR) as a measure of ranking quality.

Benchmark results are measured on an Intel Xeon E5-2686v4 CPU by running a 100 repetitions of scoring 100,000 items and averaging the results.

\subsection{Implementation}
The model is implemented in PyTorch and trained using the nVidia K40 GPUs. The implementation is only marginally more complex than a standard learning-to-rank model, and is accomplished by simply replacing the user-item vector dot product operation with its binary counterpart. The change results in a small increase in training time.

During training, the embedding parameters are stored and updated as single precision floating point values. Similarly, the XNOR dot product is carried out using floats in $\{1, -1\}$. The minibatch size and number of training epochs are treated as model hyperparameters. All models are trained using the Adam training rate schedule \citep{kingma2014adam}.

The prediction code runs on the CPU and is implemented in C using Intel X86 AVX2 SIMD intrinsics. SIMD (Single Instruction Multiple Data) instructions allow the CPU to operate on multiple pieces of data in parallel, achieving significant speedups over the scalar version. We use explicit intrinsics rather than compiler autovectorization to ensure that neither the real-valued nor the binary prediction code is unfairly disadvantaged by the quality of compiler autovectorization. 

The real-valued prediction code is implemented using 8-float wide fused multiply-add instructions (\texttt{\_mm256\_fmadd\_ps}). In the binary version, the real-valued embedding parameters used in training are discarded, and the derived 1-bit weights are packed into 32-bit integer buffers. The XNOR dot product is implemented using 8-integer wide XOR operations (256 binary weights are processed at a time), followed by a popcount instruction to count the number of on bits in the result. We use the \texttt{libpopcnt} \citep{mula2016faster} library for the bit counting operations.

Both versions use 32-bit aligned input data to utilise aligned SIMD register load instructions. The code is compiled using GCC 4.8.4 for the AVX2-enabled Broadwell architecture.

The source code for both model training and prediction is available on Github at \url{https://github.com/maciejkula/binge}.

\subsection{Results}
\label{sec:results}
Table \ref{tb:results} summarises the results of the Movielens 100K experiment. Each row presents the best MRR (mean reciprocal rank) results for both real-valued and binary models of a given dimensionality. MRR ratio denotes the fraction of the real-valued MRR the binary model achieves for that dimensionality; PPMS (predictions per millisecond) ratio denotes how many more predictions the binary model can compute per millisecond.

Results on scoring speed and memory use broadly confirm the naive calculations from section \ref{sec:approach}, converging to over 20 times faster scoring at around 3\% of memory as latent dimensionality increases. Memory savings plateau as latent dimensionality increases and storing the binary scaling factors becomes less important.

As expected, for the same dimensionality a binary model achieves lower ranking accuracy. On average, the accuracy loss is around 8\%, varying between 2\% and 16\%.
Nevertheless, the model's speed enables some very favourable tradeoffs.

When optimizing for MRR in both settings (at 1024 dimensions for the continuous and 2048 for the binary case), the XNOR representation achieves 96\% of the maximum MRR of the float representations at 13 times the query throughput and using only 6\% of the memory.

When optimizing for query throughput at 32 dimensions for the continuous case, the XNOR representation (at 512 dimensions) can improve the ranking performance by achieving 110\% of the continuous MRR while being slightly faster at 1.2 times the query throughput, and using 55\% of the memory.

\section{Related work}
Much of existing work on efficient recommendation retrieval focuses on reducing the number of dot products that need to be performed in order to retrieve top recommendations. \citet{koenigstein2012efficient} introduces an exact branch-and-bound based on metric trees as well as an approximate algorithm that clusters users and serves recommendations computed for the cluster centers. \citet{shrivastava2014asymmetric} extend well-known \citep{indyk1998approximate} locality-sensitive hashing techniques to maximum inner product search (MIPS) through asymmetric transformations of the query and candidate vectors.

Our work complements these approaches. Binary representations are direct replacement for existing real-valued recommendations, and will serve to speed up the final predictions on the set of candidates returned from tree nodes or hash buckets.

The method that is most closely related to the model we present in this paper is \citet{Shen_2015_ICCV}, who expand on MIPS by learning asymmetric binary hash functions. The hash functions are trained to minimize the L2 norm between the inner product matrix of the original input vectors and the inner product matrix of their binary representations. As a post-processing technique, it is a applicable to a wide range of problems. However, because the binary representations are obtained as a separate step, this approach may not be able to exploit the benefits in training a binary representation approach end-to-end.

\section{Conclusion and future work}
We show that binary user and item representations allow recommender system designers to exploit an attractive new set of speed-accuracy trade-offs. They are straightforward to estimate, and can easily be used in any existing model estimated using stochastic gradient descent.

There are a number of ways in which our work could be extended. An increasing number of recommender applications employ more sophisticated models using recurrent units for sequence representations or convolutional units for incorporating image data. Our approach can easily be applied in such models by simply replacing the topmost dot product or softmax layers with their binary equivalents.


\bibliography{bibliography}
\bibliographystyle{ACM-Reference-Format}

\end{document}
